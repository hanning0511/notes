Tags: #Rust #Package #Crate
Refs: [packages and crates](https://rustwiki.org/zh-CN/book/ch07-01-packages-and-crates.html), [Crates and Modules](https://www.cs.brandeis.edu/~cs146a/rust/doc-02-21-2015/book/crates-and-modules.html)

# Rust 模块系统

## 包和crate

- crate 是一个二进制项或者库。
- **crate root** 是一个源文件，Rust 编译器以它为起始点，构建你的 crate 的根模块。
- 包是提供了一些列功能的一个或者多个 crate。一个包会包含一个 `Cargo.toml` 文件，阐述如何构建这些 crates。

包中所包含的的内容有几条规则确立：

1. 一个包中至多包含一个库 crate (library crate)；
2. 包中可以包含任意对二进制 crate (binary crate)；
3. 包中至少包含一个 crate，无论是库或者二进制。

Cargo 遵循一个约定：`src/main.rs` 就是一个与包同名的二进制 crate 的 **crate root**。同样的，如果包目录中包含 `src/lib.rs` ，则包带有与其同名的库 crate，且 `src/lib.rs` 就是库 crate 的 **root crate**。如果一个包里同时包含 `src/main.rs` 和 `src/lib.rs`，则它有两个 crates。

通过把文件放在 `/sr/bin` 目录下，一个包可以拥有多个二进制 crates：每个 `src/bin` 下的文件都会被编译成一个独立的二进制 crate。

一个 crate 会将一个作用域内的相关功能分组到一起，使得改功能可以很方便地在多个项目之间共享。

## 定义模块用来控制作用域和私有性

模块让我们可以将一个 crate 中的代码进行分组，可以提高可读性和重用性。模块还可以控制项的私有性，即项是可以被外部代码使用（public），还是作为一个内部实现的内容，不能被外部代码使用（private）。

我们用 `mod` 关键字定义一个模块，指定模块的名字，并用大括号包围模块的主题。可以在模块中包含其他模块。模块中也可以包含其他项，比如结构体，枚举，常量，Trait 和函数。

```Rust
mod front_of_house {
	mod hosting {
		fn add_to_waitlist() {}
		fn seat_at_table() {}
	}

	mod serving {
		fn take_order() {}
		fn server_order() {}
		fn take_payment() {}
	}
}
```

下图展示了上面代码对应的模块树

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

## 路径用于引用模块树中的项

来看下 Rust 如何在模块中找到一个项的位置，我们使用路径的方式，就想文件系统的路径一样。如果要调用一个函数，我们需要知道它的路径。

路径有两种方式：

- **绝对路径**： 从 crate root 开始，以 crate 名或者字面量 `crate` 开头。
- **相对路径**：从当前模块开始，以 `self` 、`super` 或者当前模块的标识符开头。

路径后都跟一个或多个又双冒号（`::`）分隔的标识符。

### 使用 `pub` 关键字暴露路径

模块不仅对于你组织代码很有用。他们还定义了 Rust 的 _私有性边界_（_privacy boundary_）：这条界线不允许外部代码了解、调用和依赖被封装的实现细节。所以，如果你希望创建一个私有函数或结构体，你可以将其放入模块。

Rust 中默认所有项（函数、方法、结构体、枚举、模块和常量）都是私有的。父模块中的项不能使用子模块中的私有项，但是子模块中的项可以使用他们父模块中的项。这是因为子模块封装并隐藏了他们的实现详情，但是子模块可以看到他们定义的上下文。继续拿餐馆作比喻，把私有性规则想象成餐馆的后台办公室：餐馆内的事务对餐厅顾客来说是不可知的，但办公室经理可以洞悉其经营的餐厅并在其中做任何事情。

Rust 选择以这种方式来实现模块系统功能，因此默认隐藏内部实现细节。这样一来，你就知道可以更改内部代码的哪些部分而不会破坏外部代码。你还可以通过使用 `pub` 关键字来创建公共项，使子模块的内部部分暴露给上级模块。

### 使用 `super` 开头的相对路径

我们还可以使用 `super` 开头来构建从父模块开始的相对路径。这么做类似于文件系统中以 `..` 开头的语法。

### 创建公有的结构体和枚举

我们还可以使用 `pub` 来设计公有的结构体和枚举，不过有一些额外的细节需要注意。如果我们在一个结构体定义的前面使用了 `pub` ，这个结构体会变成公有的，但是这个结构体的字段仍然是私有的。我们可以根据情况决定每个字段是否公有。


## 使用 `use` 关键字将名称引入作用域

无论是使用绝对路径还是相对路径，如果模块嵌套的层数很多，每一次都调用都使用路径，就会很繁琐，为了解决这个问题，我们可以使用 `use` 关键字把路径或项一次性引入当前作用域。

### 使用 `use` 引入项到作用域的惯用法

- 对于函数，一般引入其父模块，这样可以清晰地表明函数不是在当前作用域定义的。
- 对于结构体和枚举，一般引入其完整路径。

上面两种只是习惯用法，并不是强制规定。

### 使用 `as` 关键字提供新的名称

使用 `use` 引入同名类型进入同一作用域的时候，可以使用 `as` 关键字给类型重命名。

```Rust
use std::fmt::Reuslt as FmtResult;
use std::io::Result as IoResult;
```

### 使用外部包

如果我们需要使用一个叫 `rand` 的外部包。我们需要在 `Cargo.toml` 中加入如下行：

```toml
[dependencies]
rand = "0.8.3"
```

这告诉 `cargo` 要从 [crates.io](https://crates.io/)下载 `rand` 和其依赖，并使其可在项目代码中使用。

接着，为了将 `rand` 定义引入项目包的作用域，我们加入一行 `use` 其实的包名，它以 `rand` 开头并列出了需要引入作用域的项。

```Rust
use rand::Rng;
```


## 将模块分割到不同的文件

随着项目规模变大，再把所有的模块都放在同一个文件中显然不合适了，这时候我们可能要将它们移动到不同的文件中，使得代码更容易阅读和维护。

把模块移动到不同文件时，遵循如下约定：

1. 文件名就是模块名。
2. 需要在父模块显示声明被移动到单个文件的模块。

